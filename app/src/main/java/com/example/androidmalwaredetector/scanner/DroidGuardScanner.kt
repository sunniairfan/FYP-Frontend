package com.example.androidmalwaredetector.scanner
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONArray
import org.json.JSONObject
import org.tensorflow.lite.Interpreter
import com.example.androidmalwaredetector.scanner.utils.Sha256HashExtractor
import com.example.androidmalwaredetector.scanner.utils.IntentExtractor
import java.io.IOException
import java.io.InputStream
import java.nio.MappedByteBuffer
import java.nio.channels.FileChannel
import java.io.FileInputStream
import kotlin.math.min

class DroidGuardScanner(private val context: Context) {
    
    private var tfliteInterpreter: Interpreter? = null
    private var permissionsArray: JSONArray? = null
    private var intentsArray: JSONArray? = null
    private var isModelLoaded = false
    
    companion object {
        private const val MODEL_FILE = "saved_model.tflite"
        private const val FEATURES_FILE = "features.json"
        private const val FEATURE_VECTOR_SIZE = 2000
        private const val PERMISSIONS_OFFSET = 0
        private const val INTENTS_OFFSET = 489
        
        // Threat thresholds
        private const val MALWARE_THRESHOLD = 0.75f
        private const val SUSPICIOUS_THRESHOLD = 0.5f
    }

    suspend fun initialize(): Boolean = withContext(Dispatchers.IO) {
        try {
            if (isModelLoaded) return@withContext true
            
            // Load TensorFlow Lite model
            val modelBuffer = loadModelFile()
            tfliteInterpreter = Interpreter(modelBuffer)
            
            // Load feature definitions
            val featuresJson = loadFeaturesJson()
            val jsonObject = JSONObject(featuresJson)
            permissionsArray = jsonObject.getJSONArray("permissions")
            intentsArray = jsonObject.getJSONArray("intents")
            
            isModelLoaded = true
            true
        } catch (e: Exception) {
            false
        }
    }
    

    suspend fun scanApp(
        packageName: String,
        config: ScanConfig = ScanConfig()
    ): ScanResult = withContext(Dispatchers.IO) {
        
        try {
            // Ensure model is loaded
            if (!isModelLoaded && !initialize()) {
                return@withContext ScanResult.Error(
                    packageName = packageName,
                    exception = ScanException("Failed to initialize scanner", errorCode = ErrorCode.MODEL_LOAD_FAILED)
                )
            }
            
            val packageManager = context.packageManager
            val packageInfo = try {
                packageManager.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS)
            } catch (e: PackageManager.NameNotFoundException) {
                return@withContext ScanResult.Error(
                    packageName = packageName,
                    exception = ScanException("Package not found: $packageName", ErrorCode.PACKAGE_NOT_FOUND, e)
                )
            }
            
            val applicationInfo = packageInfo.applicationInfo ?: return@withContext ScanResult.Error(
                packageName = packageName,
                exception = ScanException("Application info not found", ErrorCode.PACKAGE_NOT_FOUND)
            )
            val isSystemApp = (applicationInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0
            
            // Skip system apps if not configured to include them
            if (isSystemApp && !config.includeSystemApps) {
                return@withContext ScanResult.Success(
                    packageName = packageName,
                    appName = applicationInfo.loadLabel(packageManager).toString(),
                    prediction = ThreatLevel.SAFE,
                    confidence = 0f,
                    isSystemApp = isSystemApp
                )
            }
            
            val appName = applicationInfo.loadLabel(packageManager).toString()
            
            // Extract app features
            val permissions = extractPermissions(packageName)
            val intents = extractIntents(packageName)
            
            // Check if app has any relevant features
            if (permissions.isEmpty() && intents.isEmpty()) {
                return@withContext ScanResult.Success(
                    packageName = packageName,
                    appName = appName,
                    prediction = ThreatLevel.UNKNOWN,
                    confidence = 0f,
                    isSystemApp = isSystemApp
                )
            }
            
            // Create feature vector
            val featureVector = createFeatureVector(permissions, intents)
            
            // Run ML prediction
            val confidence = runPrediction(featureVector)
            val threatLevel = classifyThreat(confidence)
            
            // Extract SHA256 hash if requested
            val sha256Hash = if (config.extractSha256) {
                try {
                    Sha256HashExtractor.getSha256Hash(applicationInfo.publicSourceDir ?: "")
                } catch (e: Exception) {
                    null
                }
            } else null
            
            // Create scan features if requested
            val scanFeatures = if (config.includeFeatures) {
                ScanFeatures(
                    permissions = permissions,
                    intents = intents,
                    featureVector = featureVector.toList()
                )
            } else null
            
            ScanResult.Success(
                packageName = packageName,
                appName = appName,
                prediction = threatLevel,
                confidence = confidence,
                sha256Hash = sha256Hash,
                features = scanFeatures,
                isSystemApp = isSystemApp
            )
            
        } catch (e: Exception) {
            ScanResult.Error(
                packageName = packageName,
                exception = ScanException("Scan failed: ${e.message}", ErrorCode.UNKNOWN, e)
            )
        }
    }
    
    /**
     * Scan multiple apps with progress callback
     */
    suspend fun scanApps(
        packageNames: List<String>,
        config: ScanConfig = ScanConfig(),
        progressCallback: ScanProgressCallback? = null
    ): List<ScanResult> = withContext(Dispatchers.IO) {
        
        val results = mutableListOf<ScanResult>()
        
        packageNames.forEachIndexed { index, packageName ->
            progressCallback?.onProgress(index, packageNames.size, packageName)
            
            val result = scanApp(packageName, config)
            results.add(result)
        }
        
        progressCallback?.onProgress(packageNames.size, packageNames.size, "")
        results
    }
    
    /**
     * Scan all installed apps
     */
    suspend fun scanAllInstalledApps(
        config: ScanConfig = ScanConfig(),
        progressCallback: ScanProgressCallback? = null
    ): List<ScanResult> = withContext(Dispatchers.IO) {
        
        val packageManager = context.packageManager
        val installedApps = packageManager.getInstalledApplications(PackageManager.GET_META_DATA)
        
        val packageNames = installedApps.map { it.packageName }
        scanApps(packageNames, config, progressCallback)
    }
    
    /**
     * Extract permissions from an app
     */
    private fun extractPermissions(packageName: String): List<String> {
        return try {
            val packageInfo = context.packageManager.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS)
            packageInfo.requestedPermissions?.toList() ?: emptyList()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Extract intents from an app's manifest
     */
    private fun extractIntents(packageName: String): List<String> {
        return try {
            val packageContext = context.createPackageContext(packageName, 0)
            IntentExtractor.extractIntents(packageContext)
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Create feature vector from permissions and intents
     */
    private fun createFeatureVector(permissions: List<String>, intents: List<String>): FloatArray {
        val featureVector = FloatArray(FEATURE_VECTOR_SIZE)
        
        // Set permission features
        permissionsArray?.let { permArray ->
            for (i in 0 until min(permArray.length(), FEATURE_VECTOR_SIZE)) {
                val permission = permArray.optString(i)
                featureVector[PERMISSIONS_OFFSET + i] = if (permissions.contains(permission)) 1.0f else 0.0f
            }
        }
        
        // Set intent features
        intentsArray?.let { intentArray ->
            for (i in 0 until min(intentArray.length(), FEATURE_VECTOR_SIZE - INTENTS_OFFSET)) {
                val intent = intentArray.optString(i)
                featureVector[INTENTS_OFFSET + i] = if (intents.contains(intent)) 1.0f else 0.0f
            }
        }
        
        return featureVector
    }
    
    /**
     * Run ML prediction on feature vector
     */
    private fun runPrediction(featureVector: FloatArray): Float {
        val input = arrayOf(featureVector)
        val output = Array(1) { FloatArray(1) }
        
        tfliteInterpreter?.run(input, output)
        return output[0][0]
    }
    
    /**
     * Classify threat level based on confidence score
     */
    private fun classifyThreat(confidence: Float): ThreatLevel {
        return when {
            confidence > MALWARE_THRESHOLD -> ThreatLevel.MALWARE
            confidence > SUSPICIOUS_THRESHOLD -> ThreatLevel.SUSPICIOUS
            else -> ThreatLevel.SAFE
        }
    }
    
    /**
     * Load TensorFlow Lite model from assets
     */
    private fun loadModelFile(): MappedByteBuffer {
        val assetManager = context.assets
        val fileDescriptor = assetManager.openFd(MODEL_FILE)
        val inputStream = FileInputStream(fileDescriptor.fileDescriptor)
        val fileChannel = inputStream.channel
        val startOffset = fileDescriptor.startOffset
        val declaredLength = fileDescriptor.declaredLength
        return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength)
    }
    
    /**
     * Load features JSON from assets
     */
    private fun loadFeaturesJson(): String {
        return try {
            val inputStream: InputStream = context.assets.open(FEATURES_FILE)
            val size = inputStream.available()
            val buffer = ByteArray(size)
            inputStream.read(buffer)
            inputStream.close()
            String(buffer, Charsets.UTF_8)
        } catch (e: IOException) {
            throw ScanException("Failed to load features file", ErrorCode.MODEL_LOAD_FAILED, e)
        }
    }
    
    /**
     * Clean up resources
     */
    fun cleanup() {
        tfliteInterpreter?.close()
        tfliteInterpreter = null
        isModelLoaded = false
    }
}