package com.example.androidmalwaredetector.util

import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.res.XmlResourceParser
import org.json.JSONObject
import org.tensorflow.lite.Interpreter
import org.xmlpull.v1.XmlPullParser
import java.io.File
import java.io.FileInputStream
import java.nio.MappedByteBuffer
import java.nio.channels.FileChannel

class MalwareDetector(private val context: Context) {
    
    private var tfliteInterpreter: Interpreter? = null
    private var selectedFeatures: JSONObject? = null
    private val permissionsList: MutableList<String> = mutableListOf()
    private val intentsList: MutableList<String> = mutableListOf()
    private val featureSize: Int
        get() = permissionsList.size + intentsList.size
    
    init {
        loadSelectedFeatures()
        loadModel()
        logModelInfo()
    }
    
    private fun logModelInfo() {
        try {
            if (tfliteInterpreter == null) {
                android.util.Log.w("MalwareDetector", "Cannot log model info: interpreter is null")
                return
            }
            
            android.util.Log.d("MalwareDetector", "=== MODEL INFO ===")
            android.util.Log.d("MalwareDetector", "Feature size loaded: $featureSize")
            android.util.Log.d("MalwareDetector", "Permissions: ${permissionsList.size}, Intents: ${intentsList.size}")
            
            // Try to get tensor info using getInputTensor
            try {
                val inputTensor = tfliteInterpreter!!.getInputTensor(0)
                val shape = inputTensor.shape()
                android.util.Log.d("MalwareDetector", "Input tensor shape: ${shape.contentToString()}")
            } catch (e: Exception) {
                android.util.Log.d("MalwareDetector", "Could not get input tensor info: ${e.message}")
            }
            
            try {
                val outputTensor = tfliteInterpreter!!.getOutputTensor(0)
                val shape = outputTensor.shape()
                android.util.Log.d("MalwareDetector", "Output tensor shape: ${shape.contentToString()}")
            } catch (e: Exception) {
                android.util.Log.d("MalwareDetector", "Could not get output tensor info: ${e.message}")
            }
            
            android.util.Log.d("MalwareDetector", "==================")
        } catch (e: Exception) {
            android.util.Log.w("MalwareDetector", "Error logging model info: ${e.message}")
        }
    }
    
    private fun loadModel() {
        try {
            val tfliteBuffer = loadModelFile("saved_model.tflite")
            tfliteInterpreter = Interpreter(tfliteBuffer)
            android.util.Log.d("MalwareDetector", "TFLite model loaded successfully")
        } catch (e: Exception) {
            android.util.Log.e("MalwareDetector", "Error loading model: ${e.message}", e)
            e.printStackTrace()
        }
    }
    
    private fun loadModelFile(modelName: String): MappedByteBuffer {
        val fileDescriptor = context.assets.openFd(modelName)
        val inputStream = FileInputStream(fileDescriptor.fileDescriptor)
        val fileChannel = inputStream.channel
        val startOffset = fileDescriptor.startOffset
        val declaredLength = fileDescriptor.declaredLength
        return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength)
    }
    
    private fun loadSelectedFeatures() {
        try {
            val featuresJson = context.assets.open("features.json").bufferedReader().use { it.readText() }
            selectedFeatures = JSONObject(featuresJson)
            
            selectedFeatures?.let { features ->
                val permissionsArray = features.getJSONArray("permissions")
                for (i in 0 until permissionsArray.length()) {
                    permissionsList.add(permissionsArray.getString(i))
                }
                
                val intentsArray = features.getJSONArray("intents")
                for (i in 0 until intentsArray.length()) {
                    intentsList.add(intentsArray.getString(i))
                }
                
                android.util.Log.d("MalwareDetector", "Features loaded: ${permissionsList.size} permissions + ${intentsList.size} intents = $featureSize total")
            }
        } catch (e: Exception) {
            android.util.Log.e("MalwareDetector", "Error loading features: ${e.message}", e)
            e.printStackTrace()
        }
    }
    
    /**
     * Extract features from an app's manifest and permissions
     * Uses same logic as LibreAv: permissions at 0-488, intents at 489-1999
     */
    fun extractAppFeatures(packageName: String, packageManager: PackageManager): FloatArray {
        val featureVector = FloatArray(2000)  // Always 2000 features
        var hasFlag = false  // Flag is true if app has at least one permission or intent from features
        
        try {
            // Get app permissions from manifest
            val appPermissions = mutableSetOf<String>()
            
            try {
                val packageInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS)
                packageInfo.requestedPermissions?.forEach { permission ->
                    appPermissions.add(permission)
                }
            } catch (e: Exception) {
                android.util.Log.w("MalwareDetector", "Could not get permissions for $packageName: ${e.message}")
            }
            
            android.util.Log.d("MalwareDetector", "App: $packageName, Permissions found: ${appPermissions.size}")
            
            // Fill permission features at indices 0-488 (matching features.json order)
            for (i in permissionsList.indices) {
                if (appPermissions.contains(permissionsList[i])) {
                    featureVector[i] = 1f
                    hasFlag = true
                } else {
                    featureVector[i] = 0f
                }
            }
            
            // Extract intents from manifest
            val appIntents = extractAppIntents(packageName, packageManager)
            
            android.util.Log.d("MalwareDetector", "App: $packageName, Intents found: ${appIntents.size}")
            
            // Fill intent features at indices 489-1999 (matching features.json order)
            for (i in intentsList.indices) {
                if (appIntents.contains(intentsList[i])) {
                    featureVector[489 + i] = 1f  // Hardcoded offset like LibreAv
                    hasFlag = true
                } else {
                    featureVector[489 + i] = 0f
                }
            }
            
            if (!hasFlag) {
                android.util.Log.d("MalwareDetector", "App: $packageName has no permissions or intents in features list")
            }

        } catch (e: Exception) {
            e.printStackTrace()
        }
        
        return featureVector
    }
    
    /**
     * Extract intent filters from app manifest
     */
    private fun extractAppIntents(packageName: String, packageManager: PackageManager): Set<String> {
        val intents = mutableSetOf<String>()
        
        try {
            // Get activities
            try {
                val activityPackageInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_ACTIVITIES)
                activityPackageInfo.activities?.forEach { activity ->
                    try {
                        // Get intent filters for this activity
                        val intentFilters = packageManager.queryIntentActivities(
                            android.content.Intent().apply { 
                                setClassName(packageName, activity.name)
                                action = android.content.Intent.ACTION_VIEW
                            },
                            0
                        )
                        
                        // Add common intents based on activity name patterns
                        val activityNameLower = activity.name.lowercase()
                        
                        intents.add("android.intent.action.MAIN")
                        
                        when {
                            activityNameLower.contains("payment") || activityNameLower.contains("buy") || activityNameLower.contains("transaction") -> {
                                intents.add("android.intent.action.VIEW")
                                intents.add("android.intent.category.BROWSABLE")
                                intents.add("android.intent.action.SEND")
                            }
                            activityNameLower.contains("call") || activityNameLower.contains("phone") -> {
                                intents.add("android.intent.action.CALL")
                                intents.add("android.intent.action.CALL_BUTTON")
                            }
                            activityNameLower.contains("contact") || activityNameLower.contains("address") -> {
                                intents.add("android.intent.action.PICK")
                                intents.add("android.intent.action.VIEW")
                            }
                            activityNameLower.contains("camera") || activityNameLower.contains("photo") || activityNameLower.contains("picture") -> {
                                intents.add("android.media.action.IMAGE_CAPTURE")
                                intents.add("android.intent.action.GET_CONTENT")
                            }
                            activityNameLower.contains("location") || activityNameLower.contains("map") || activityNameLower.contains("gps") -> {
                                intents.add("android.intent.action.VIEW")
                                intents.add("android.intent.action.VIEW_LOCATION")
                            }
                            activityNameLower.contains("browser") || activityNameLower.contains("web") || activityNameLower.contains("url") -> {
                                intents.add("android.intent.action.VIEW")
                                intents.add("android.intent.category.BROWSABLE")
                            }
                            activityNameLower.contains("music") || activityNameLower.contains("media") || activityNameLower.contains("audio") -> {
                                intents.add("android.intent.action.VIEW")
                                intents.add("android.media.action.PLAY_MUSIC")
                            }
                        }
                    } catch (e: Exception) {
                        // Continue processing
                    }
                }
            } catch (e: Exception) {
                android.util.Log.w("MalwareDetector", "Could not extract activities: ${e.message}")
            }
            
            // Extract from broadcast receivers
            try {
                val receiverPackageInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_RECEIVERS)
                receiverPackageInfo.receivers?.forEach { receiver ->
                    val receiverNameLower = receiver.name.lowercase()
                    
                    when {
                        receiverNameLower.contains("sms") -> {
                            intents.add("android.provider.Telephony.SMS_RECEIVED")
                            intents.add("android.intent.action.PHONE_STATE")
                        }
                        receiverNameLower.contains("boot") -> {
                            intents.add("android.intent.action.BOOT_COMPLETED")
                        }
                        receiverNameLower.contains("network") -> {
                            intents.add("android.net.conn.CONNECTIVITY_CHANGE")
                        }
                        receiverNameLower.contains("power") -> {
                            intents.add("android.intent.action.BATTERY_CHANGED")
                        }
                        receiverNameLower.contains("time") -> {
                            intents.add("android.intent.action.TIME_TICK")
                        }
                    }
                }
            } catch (e: Exception) {
                android.util.Log.w("MalwareDetector", "Could not extract receivers: ${e.message}")
            }
            
            // Extract from services
            try {
                val servicePackageInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_SERVICES)
                servicePackageInfo.services?.forEach { service ->
                    val serviceNameLower = service.name.lowercase()
                    
                    when {
                        serviceNameLower.contains("location") -> {
                            intents.add("android.intent.action.LOCATION_UPDATES")
                        }
                        serviceNameLower.contains("sync") -> {
                            intents.add("android.intent.action.SYNC")
                        }
                        serviceNameLower.contains("notification") -> {
                            intents.add("android.intent.action.MAIN")
                        }
                    }
                }
            } catch (e: Exception) {
                android.util.Log.w("MalwareDetector", "Could not extract services: ${e.message}")
            }
            

        } catch (e: Exception) {
            e.printStackTrace()
        }
        
        return intents
    }
    
    /**
     * Predict malware threat level for an app
     */
    fun predictMalware(packageName: String, packageManager: PackageManager): MLPredictionResult {
        return try {
            if (tfliteInterpreter == null) {
                android.util.Log.e("MalwareDetector", "TFLite interpreter is null")
                return MLPredictionResult(
                    score = 0.5f,
                    label = "unknown",
                    confidence = 0.0f
                )
            }
            
            val features = extractAppFeatures(packageName, packageManager)
            
            // Check if feature size is exactly 2000
            if (features.size != 2000) {
                android.util.Log.e("MalwareDetector", "Feature size mismatch: got ${features.size}, expected 2000")
                return MLPredictionResult(
                    score = 0.5f,
                    label = "unknown",
                    confidence = 0.0f
                )
            }
            
            android.util.Log.d("MalwareDetector", "Running inference for $packageName with 2000 features")
            
            // Model expects input shape [1, 2000] and output shape [1, 1]
            // Wrap features in 2D array: [1, 2000]
            val inputBuffer = Array(1) { features }
            val output = Array(1) { FloatArray(1) }
            
            // Run the model using runForMultipleInputsOutputs
            // The output map needs the FULL 2D array, not output[0]
            try {
                val outputMap = mapOf(0 to output)
                tfliteInterpreter!!.runForMultipleInputsOutputs(inputBuffer, outputMap)
            } catch (e: Exception) {
                android.util.Log.e("MalwareDetector", "Inference failed: ${e.message}")
                throw e
            }
            
            val predictionScore = output[0][0]
            android.util.Log.d("MalwareDetector", "App: $packageName, Prediction score: $predictionScore [0-1 probability range, NOT percentage]")
            
            // Determine label based on prediction score using LibreAv thresholds
            // > 0.75 = MALWARE
            // > 0.5 = RISKY
            // <= 0.5 = SAFE
            val label = when {
                predictionScore > 0.75f -> "malware"  // High probability = malware
                predictionScore > 0.5f -> "risky"     // Medium probability = risky
                else -> "safe"                        // Low probability = safe
            }
            
            android.util.Log.d("MalwareDetector", "App: $packageName -> Score: $predictionScore [0-1], Label: $label")
            
            android.util.Log.d("MalwareDetector", "App: $packageName -> Score: $predictionScore [0-1 probability], Label: $label")
            
            MLPredictionResult(
                score = predictionScore,
                label = label,
                confidence = kotlin.math.abs(predictionScore - 0.5f) * 2
            )
        } catch (e: Exception) {
            android.util.Log.e("MalwareDetector", "predictMalware exception: ${e.message}", e)
            e.printStackTrace()
            MLPredictionResult(
                score = 0.5f,
                label = "unknown",
                confidence = 0.0f
            )
        }
    }
    
    /**
     * Check if an app is a system app
     */
    fun isSystemApp(appInfo: ApplicationInfo): Boolean {
        return (appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0
    }
    
    fun release() {
        try {
            tfliteInterpreter?.close()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}

data class MLPredictionResult(
    val score: Float,
    val label: String,
    val confidence: Float
)
