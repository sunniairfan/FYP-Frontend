package com.example.androidmalwaredetector.util

import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PermissionInfo
import android.util.Log
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.io.IOException
import kotlinx.coroutines.*

// List of system package prefixes that are unreliable or should be excluded
private val UNRELIABLE_SYSTEM_PREFIXES = listOf(
    "com.android.cts",
    "com.google.android.test",
    "android.ext",
    "com.qualcomm.",
    "com.coloros.",
    "com.oplus.",
    "com.vivo.",
    "com.miui.",
    "com.huawei.",
    "com.xiaomi.",
    "com.samsung.",
    "com.sec.",
    "org.lineageos.",
    "android.test",
    "com.android.test"
)

// List of authentic system apps that should always be included
private val AUTHENTIC_SYSTEM_PACKAGES = setOf(
    "android",
    "com.android.systemui",
    "com.android.launcher3",
    "com.android.phone",
    "com.android.contacts",
    "com.android.dialer",
    "com.android.calendar",
    "com.android.email",
    "com.android.messaging",
    "com.android.gallery3d",
    "com.android.camera2",
    "com.android.deskclock",
    "com.android.documentsui",
    "com.android.packageinstaller",
    "com.android.settings",
    "com.android.providers.media",
    "com.android.providers.contacts",
    "com.android.providers.calendar",
    "com.google.android.apps.maps",
    "com.google.android.apps.mediashell",
    "com.google.android.apps.photos",
    "com.google.android.googlequicksearchbox",
    "com.google.android.gms",
    "com.google.android.webview"
)

// Function to check if a system app is authentic and should be included
private fun isAuthenticSystemApp(packageName: String): Boolean {
    // Check if it's in the authentic list
    if (AUTHENTIC_SYSTEM_PACKAGES.contains(packageName)) {
        return true
    }
    
    // Check if it's a known unreliable system app
    if (UNRELIABLE_SYSTEM_PREFIXES.any { packageName.startsWith(it) }) {
        return false
    }
    
    // For other system apps, only include if they're from official sources
    val officialPrefixes = listOf(
        "com.google.",
        "com.android.",
        "android."
    )
    
    return officialPrefixes.any { packageName.startsWith(it) }
}

// Function to upload metadata of system apps ONLY to a server
// NO ML model is run on system apps
fun uploadSystemApps(context: Context) {
    // Get PackageManager to query installed apps
    val pm = context.packageManager
    
    // Get all installed apps
    val allInstalledApps = pm.getInstalledApplications(PackageManager.GET_META_DATA)
    
    // Array for system apps only
    val systemAppsArray = JSONArray()
    
    // Process each app - ONLY AUTHENTIC SYSTEM APPS
    for (app in allInstalledApps) {
        try {
            // Determine if app is system or user app
            val isSystem = (app.flags and ApplicationInfo.FLAG_SYSTEM) != 0
            
            // ONLY process authentic system apps
            if (!isSystem) {
                continue
            }
            
            // Skip system apps that are not authentic
            if (!isAuthenticSystemApp(app.packageName)) {
                continue
            }
            
            // Get app name from PackageManager
            val appName = pm.getApplicationLabel(app).toString()
            
            // Skip apps with blank names
            if (appName.isBlank()) {
                continue
            }
            
            val apkPath = app.sourceDir
            if (apkPath.isNullOrBlank()) {
                Log.w("SystemUpload", "Skipping system app ${app.packageName}: sourceDir is null or blank")
                continue
            }
            
            val apkFile = File(apkPath)
            
            // Check if APK file exists before attempting to hash
            if (!apkFile.exists()) {
                Log.w("SystemUpload", "Skipping system app ${app.packageName}: APK file not found at $apkPath")
                continue
            }
            
            // Get SHA256 hash - skip if hash cannot be computed
            val sha256 = try {
                getSha256(apkFile)
            } catch (e: Exception) {
                Log.w("SystemUpload", "Failed to compute hash for ${app.packageName}: ${e.message}")
                // Skip apps where hash cannot be computed
                continue
            }
            
            val appSizeMb = String.format("%.2f", apkFile.length().toDouble() / (1024 * 1024)).toDouble()

            val permissionList = mutableListOf<String>()
            try {
                val packageInfo = pm.getPackageInfo(app.packageName, PackageManager.GET_PERMISSIONS)
                val requestedPermissions = packageInfo.requestedPermissions ?: emptyArray()

                for (perm in requestedPermissions) {
                    try {
                        val permInfo = pm.getPermissionInfo(perm, 0)
                        if ((permInfo.protectionLevel and PermissionInfo.PROTECTION_DANGEROUS) != 0) {
                            permissionList.add(perm)
                        }
                    } catch (_: Exception) {}
                }
            } catch (e: Exception) {
                Log.w("SystemUpload", "Failed to get permissions for ${app.packageName}: ${e.message}")
                // Continue without permissions rather than skipping the app
            }
            
            // Create JSON object for the system app
            val appJson = JSONObject().apply {
                put("appName", appName)
                put("packageName", app.packageName)
                put("sizeMB", appSizeMb)
                put("sha256", sha256)
                put("permissions", JSONArray(permissionList))
                put("appType", "system")
            }

            // Add to system apps array
            systemAppsArray.put(appJson)
            Log.d("SystemUpload", "Added system app: ${app.packageName}")

        } catch (e: Exception) {
            Log.e("SystemUpload", "Error processing system app: ${e.message}")
            e.printStackTrace()
        }
    }

    // Check if we have any apps to upload
    if (systemAppsArray.length() == 0) {
        Log.w("SystemUpload", "No system apps found to upload.")
        return
    }
    
    Log.i("SystemUpload", "Uploading ${systemAppsArray.length()} system apps")
    
    // Create JSON payload with system apps only
    val jsonPayload = JSONObject().apply {
        put("systemApps", systemAppsArray)
    }
    
    // Create request body with JSON content type
    val body = RequestBody.create(
        "application/json; charset=utf-8".toMediaType(),
        jsonPayload.toString()
    )
    
    // Build HTTP POST request
    val request = Request.Builder()
        .url("http://192.168.137.1:5000/api/app/upload")
        .post(body)
        .build()
    
    // Send request asynchronously using OkHttp
    val client = OkHttpClient()
    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            Log.e("SystemUpload", "‚ùå Failed to upload system app data: ${e.message}")
        }

        override fun onResponse(call: Call, response: Response) {
            // Process server response
            response.body?.string()?.let { responseString ->
                try {
                    val json = JSONObject(responseString)
                    
                    Log.d("SystemUpload", "Response from server: $responseString")
                    
                    // Check if response has systemApps array
                    if (!json.has("systemApps")) {
                        // Fallback: try old format with "results" array
                        if (json.has("results")) {
                            Log.w("SystemUpload", "Server returned old format. Attempting to parse 'results' array.")
                            val resultsArray = json.getJSONArray("results")
                            for (i in 0 until resultsArray.length()) {
                                val result = resultsArray.getJSONObject(i)
                                val packageName = result.getString("packageName")
                                val status = result.optString("status", "unknown")
                                appStatusMap[packageName] = status
                                Log.i("AppStatus", "System App: $packageName ‚ûú Status: $status")
                            }
                        } else {
                            Log.e("SystemUpload", "Invalid response: Missing systemApps array")
                        }
                        return@let
                    }
                    
                    // Process systemApps array - NEW: ML MODEL IS NOW RUN FOR SYSTEM APPS (SAME AS USER APPS)
                    if (json.has("systemApps")) {
                        try {
                            val systemAppsArray = json.getJSONArray("systemApps")
                            Log.d("SystemUpload", "Processing ${systemAppsArray.length()} system apps from response")
                            
                            for (i in 0 until systemAppsArray.length()) {
                                try {
                                    val result = systemAppsArray.getJSONObject(i)
                                    val packageName = result.getString("packageName")
                                    val status = result.optString("status", "unknown")
                                    val source = result.optString("source", "unknown")
                                    
                                    // Extract VirusTotal hash check details if available
                                    val virusTotalInfo = if (result.has("virusTotalHashCheck")) {
                                        try {
                                            val vtCheck = result.getJSONObject("virusTotalHashCheck")
                                            val detectionRatio = vtCheck.optString("detectionRatio", "0/0")
                                            val scanTime = vtCheck.optString("scanTime", "N/A")
                                            "\n  VirusTotal: $detectionRatio | Scan: $scanTime"
                                        } catch (e: Exception) {
                                            ""
                                        }
                                    } else {
                                        ""
                                    }
                                    
                                    // Store status in map
                                    appStatusMap[packageName] = status
                                    
                                    Log.i("AppStatus", "System App: $packageName ‚ûú Status: $status | Source: $source$virusTotalInfo")
                                    
                                    // ‚úÖ NEW: Check if we need to run ML model:
                                    // ML model NOW RUNS on system apps with status != "safe" (SAME AS USER APPS)
                                    if (status != "safe") {
                                        Log.i("MLCheck", "üîç Running ML model for unsafe system app: $packageName (status: $status)")
                                        
                                        // Run ML model in background to avoid blocking
                                        GlobalScope.launch(Dispatchers.Default) {
                                            try {
                                                val malwareDetector = MalwareDetector(context)
                                                val prediction = malwareDetector.predictMalware(packageName, context.packageManager)
                                                
                                                // Log ML prediction in 0-1 probability format (NOT percentage)
                                                Log.i("MLPrediction", "‚úÖ System App ML prediction: $packageName ‚Üí Score: ${prediction.score} [0-1 probability], Label: ${prediction.label}")
                                                
                                                // Send ML results back to backend ONLY (score in 0-1 format)
                                                // Status badges will be updated by server response, NOT by local storage
                                                sendMLPredictionToBackend(context, packageName, prediction.score, prediction.label)
                                                
                                                malwareDetector.release()
                                            } catch (e: Exception) {
                                                Log.e("MLCheck", "‚ùå Error running ML model for system app $packageName: ${e.message}")
                                            }
                                        }
                                    } else {
                                        Log.d("SystemUpload", "‚è≠Ô∏è  System app $packageName has status 'safe' - skipping ML model execution")
                                    }
                                    
                                } catch (e: Exception) {
                                    Log.e("AppStatus", "Error parsing individual system app at index $i: ${e.message}")
                                }
                            }
                        } catch (e: Exception) {
                            Log.e("AppStatus", "Error parsing systemApps array: ${e.message}")
                            e.printStackTrace()
                        }
                    }
                    
                    Log.i("SystemUpload", "‚úÖ Successfully processed system app statuses from server. ML model execution started for unsafe apps.")
                    
                } catch (e: Exception) {
                    Log.e("AppStatus", "‚ùå Error parsing response: ${e.message}")
                    e.printStackTrace()
                }
            }
        }
    })
}
