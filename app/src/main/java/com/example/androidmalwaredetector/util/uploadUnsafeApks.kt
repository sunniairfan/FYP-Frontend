package com.example.androidmalwaredetector.util

import android.content.Context
import android.content.pm.PackageManager
import android.util.Log
import org.json.JSONArray
import org.json.JSONObject
import java.io.DataOutputStream
import java.io.File
import java.net.HttpURLConnection
import java.net.URL
import java.util.UUID
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext

/**
 * Upload APKs for apps with unsafe status (NOT "safe")
 * Uses same logic as AppDetailScreen uploadApp function
 * Adds delay between uploads to prevent server overload
 */
suspend fun uploadUnsafeApks(context: Context): Boolean {
    return withContext(Dispatchers.IO) {
        val pm = context.packageManager
        
        // Get all installed apps
        val allApps = try {
            pm.getInstalledApplications(PackageManager.GET_META_DATA)
        } catch (e: Exception) {
            Log.e("UnsafeUpload", "Error getting installed apps: ${e.message}")
            return@withContext false
        }
        
        // Filter apps with unsafe status (NOT "safe")
        val unsafeApps = allApps.filter { app ->
            val status = appStatusMap[app.packageName]?.lowercase() ?: "unknown"
            val isSafe = status.trim().lowercase() == "safe"
            
            // Log which apps we're including/excluding
            if (isSafe) {
                Log.d("UnsafeUpload", "SKIPPING (safe): ${app.packageName} status=$status")
            }
            
            // Only include if NOT safe
            !isSafe
        }
        
        if (unsafeApps.isEmpty()) {
            Log.i("UnsafeUpload", "No unsafe apps found to upload")
            return@withContext true
        }
        
        Log.i("UnsafeUpload", "Found ${unsafeApps.size} unsafe apps to upload")
        
        var successCount = 0
        var failureCount = 0
        
        // Upload each unsafe app's APK
        for ((index, app) in unsafeApps.withIndex()) {
            var conn: HttpURLConnection? = null
            try {
                val appName = pm.getApplicationLabel(app).toString()
                val packageName = app.packageName
                val status = appStatusMap[packageName]?.lowercase() ?: "unknown"
                
                // Double-check that this app is NOT safe (filter should have caught it, but verify)
                val isSafe = status.trim().lowercase() == "safe"
                if (isSafe) {
                    Log.w("UnsafeUpload", "SKIPPING in upload loop - app is safe: $packageName (status: $status)")
                    failureCount++
                    delay(1000)
                    continue
                }
                
                Log.i("UnsafeUpload", "[${index + 1}/${unsafeApps.size}] ✅ Uploading APK for $packageName (status: $status)")
                
                val apkFile = File(app.sourceDir)
                if (!apkFile.exists()) {
                    Log.w("UnsafeUpload", "APK file not found for $packageName")
                    failureCount++
                    // Delay before next upload
                    delay(1000)
                    continue
                }
                
                val sha256 = getSha256(apkFile)
                val sizeMB = apkFile.length().toDouble() / (1024 * 1024)
                
                // Create URL and connection - SAME ENDPOINT AS AppDetailScreen
                val url = URL("http://192.168.137.1:5000/uploadapp/upload")
                conn = url.openConnection() as HttpURLConnection
                
                val boundary = "----${UUID.randomUUID()}"
                conn.requestMethod = "POST"
                conn.setRequestProperty("Content-Type", "multipart/form-data; boundary=$boundary")
                conn.doOutput = true
                
                // Create JSON metadata (matching AppDetailScreen structure)
                val metadata = JSONObject().apply {
                    put("apps", JSONArray().apply {
                        put(JSONObject().apply {
                            put("appName", appName)
                            put("packageName", packageName)
                            put("sha256", sha256)
                            put("sizeMB", sizeMB)
                            put("uploadedByUser", true)
                        })
                    })
                }.toString()
                
                // Write multipart form data
                DataOutputStream(conn.outputStream).use { os ->
                    // Metadata part
                    os.writeBytes("--$boundary\r\n")
                    os.writeBytes("Content-Disposition: form-data; name=\"metadata\"\r\n")
                    os.writeBytes("Content-Type: application/json\r\n\r\n")
                    os.writeBytes(metadata)
                    os.writeBytes("\r\n")
                    
                    // APK file part
                    os.writeBytes("--$boundary\r\n")
                    os.writeBytes("Content-Disposition: form-data; name=\"apk\"; filename=\"base.apk\"\r\n")
                    os.writeBytes("Content-Type: application/vnd.android.package-archive\r\n\r\n")
                    apkFile.inputStream().use { input -> input.copyTo(os) }
                    os.writeBytes("\r\n--$boundary--\r\n")
                }
                
                // Check response
                val responseCode = conn.responseCode
                if (responseCode in 200..299) {
                    Log.i("UnsafeUpload", "✅ [${ index + 1}/${unsafeApps.size}] Uploaded APK for $packageName")
                    successCount++
                } else {
                    Log.e("UnsafeUpload", "❌ [${index + 1}/${unsafeApps.size}] Upload failed for $packageName: $responseCode")
                    failureCount++
                }
                
            } catch (e: Exception) {
                Log.e("UnsafeUpload", "Exception uploading ${app.packageName}: ${e.message}")
                failureCount++
            } finally {
                conn?.disconnect()
                // Add delay between uploads to prevent server overload (2 seconds)
                if (index < unsafeApps.size - 1) {
                    delay(2000)
                }
            }
        }
        
        Log.i("UnsafeUpload", "✅ Upload complete - Success: $successCount, Failed: $failureCount")
        return@withContext successCount > 0
    }
}
