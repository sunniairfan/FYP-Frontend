package com.example.androidmalwaredetector.util

import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PermissionInfo
import android.util.Log
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.io.IOException

// Global status map (packageName → status)
val appStatusMap = mutableMapOf<String, String>()

// Function to upload metadata of user-installed apps to a server
fun uploadUserApps(context: Context) {
    // Get PackageManager to query installed app
    val pm = context.packageManager
    // Filter for user-installed apps (non-system apps)
    val userApps = pm.getInstalledApplications(PackageManager.GET_META_DATA)
        .filter { (it.flags and ApplicationInfo.FLAG_SYSTEM) == 0 }
    // Create JSON array to hold app metadata
    val jsonArray = JSONArray()
    // Process each user app
    for (app in userApps) {
        try {
            // Get app name from PackageManager
            val appName = pm.getApplicationLabel(app).toString()
            val apkPath = app.sourceDir
            val apkFile = File(apkPath)
            val sha256 = getSha256(apkFile)
            val appSizeMb = String.format("%.2f", apkFile.length().toDouble() / (1024 * 1024)).toDouble()

            val permissionList = mutableListOf<String>()
            val packageInfo = pm.getPackageInfo(app.packageName, PackageManager.GET_PERMISSIONS)
            val requestedPermissions = packageInfo.requestedPermissions ?: emptyArray()

            for (perm in requestedPermissions) {
                try {
                    val permInfo = pm.getPermissionInfo(perm, 0)
                    if ((permInfo.protectionLevel and PermissionInfo.PROTECTION_DANGEROUS) != 0) {
                        permissionList.add(perm)
                    }
                } catch (_: Exception) {}
            }
            // Create JSON object for the app
            val appJson = JSONObject().apply {
                put("appName", appName)
                put("packageName", app.packageName)
                put("sizeMB", appSizeMb)
                put("sha256", sha256)
                put("permissions", JSONArray(permissionList))
            }

            jsonArray.put(appJson)

        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    if (jsonArray.length() == 0) {
        Log.w("Upload", "No user apps found to upload.")
        return
    }
    // Wrap the app array in a JSON object
    val jsonPayload = JSONObject().apply {
        put("apps", jsonArray)
    }
    // Create request body with JSON content type
    val body = RequestBody.create(
        "application/json; charset=utf-8".toMediaType(),
        jsonPayload.toString()
    )
    // Build HTTP POST request
    val request = Request.Builder()
        .url("http://192.168.137.1:5000/api/app/upload")
        .post(body)
        .build()
    // Send request asynchronously using OkHttp
    val client = OkHttpClient()
    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            Log.e("Upload", "❌ Failed to upload app data: ${e.message}")
        }

        override fun onResponse(call: Call, response: Response) {
            // Process server response
            response.body?.string()?.let { responseString ->
                try {
                    val json = JSONObject(responseString)
                    val resultsArray = json.getJSONArray("results")
                    // Update appStatusMap with statuses from server
                    for (i in 0 until resultsArray.length()) {
                        val result = resultsArray.getJSONObject(i)
                        val packageName = result.getString("packageName")
                        val status = result.optString("status", "unknown")

                        appStatusMap[packageName] = status
                        Log.i("AppStatus", "App: $packageName ➜ Status: $status")
                    }
                } catch (e: Exception) {
                    Log.e("AppStatus", "❌ Error parsing status: ${e.message}")
                }
            }
        }
    })
}

