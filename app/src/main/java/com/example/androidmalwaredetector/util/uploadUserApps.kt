package com.example.androidmalwaredetector.util

import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PermissionInfo
import android.util.Log
import com.example.androidmalwaredetector.model.AppInfo
import com.example.androidmalwaredetector.scanner.ScanResult
import com.example.androidmalwaredetector.scanner.ThreatLevel
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.io.IOException

// Global status map (packageName → status)
val appStatusMap = mutableMapOf<String, String>()
// Function to upload metadata of user-installed apps to a server
fun uploadUserApps(context: Context) {
    // Get PackageManager to query installed app
    val pm = context.packageManager
    // Filter for user-installed apps (non-system apps)
    val userApps = pm.getInstalledApplications(PackageManager.GET_META_DATA)
        .filter { (it.flags and ApplicationInfo.FLAG_SYSTEM) == 0 }
    // Create JSON array to hold app metadata
    val jsonArray = JSONArray()
    // Process each user app
    for (app in userApps) {
        try {
            // Get app name from PackageManager
            val appName = pm.getApplicationLabel(app).toString()
            val apkPath = app.sourceDir
            val apkFile = File(apkPath)
            val sha256 = getSha256(apkFile)
            val appSizeMb = String.format("%.2f", apkFile.length().toDouble() / (1024 * 1024)).toDouble()

            val permissionList = mutableListOf<String>()
            val packageInfo = pm.getPackageInfo(app.packageName, PackageManager.GET_PERMISSIONS)
            val requestedPermissions = packageInfo.requestedPermissions ?: emptyArray()

            for (perm in requestedPermissions) {
                try {
                    val permInfo = pm.getPermissionInfo(perm, 0)
                    if ((permInfo.protectionLevel and PermissionInfo.PROTECTION_DANGEROUS) != 0) {
                        permissionList.add(perm)
                    }
                } catch (_: Exception) {}
            }
            // Create JSON object for the app
            val appJson = JSONObject().apply {
                put("appName", appName)
                put("packageName", app.packageName)
                put("sizeMB", appSizeMb)
                put("sha256", sha256)
                put("permissions", JSONArray(permissionList))
            }

            jsonArray.put(appJson)

        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    if (jsonArray.length() == 0) {
        Log.w("Upload", "No user apps found to upload.")
        return
    }
    // Wrap the app array in a JSON object
    val jsonPayload = JSONObject().apply {
        put("apps", jsonArray)
    }
    // Create request body with JSON content type
    val body = RequestBody.create(
        "application/json; charset=utf-8".toMediaType(),
        jsonPayload.toString()
    )
    // Build HTTP POST request
    val request = Request.Builder()
        .url("http://192.168.137.1:5000/api/app/upload")
        .post(body)
        .build()
    // Send request asynchronously using OkHttp
    val client = OkHttpClient()
    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            Log.e("Upload", "❌ Failed to upload app data: ${e.message}")
        }

        override fun onResponse(call: Call, response: Response) {
            // Process server response
            response.body?.string()?.let { responseString ->
                try {
                    val json = JSONObject(responseString)
                    val resultsArray = json.getJSONArray("results")
                    // Update appStatusMap with statuses from server
                    for (i in 0 until resultsArray.length()) {
                        val result = resultsArray.getJSONObject(i)
                        val packageName = result.getString("packageName")
                        val status = result.optString("status", "unknown")

                        appStatusMap[packageName] = status
                        Log.i("AppStatus", "App: $packageName ➜ Status: $status")
                    }
                } catch (e: Exception) {
                    Log.e("AppStatus", "❌ Error parsing status: ${e.message}")
                }
            }
        }
    })
}

// Function to upload ML scanner analysis results to backend (user apps only)
fun uploadMLAnalysisResults(context: Context, scanResults: List<ScanResult.Success>) {
    // Filter only user apps (non-system apps)
    val userAppResults = scanResults.filter { result ->
        result.isSystemApp == false // Only user apps
    }
    
    if (userAppResults.isEmpty()) {
        Log.w("MLUpload", "No user app ML results to upload.")
        return
    }
    
    // Create JSON array to hold ML analysis results
    val jsonArray = JSONArray()
    
    // Process each user app result
    for (result in userAppResults) {
        try {
            // Map ThreatLevel to backend status format
            val mlStatus = when (result.prediction) {
                ThreatLevel.SAFE -> "safe"
                ThreatLevel.MALWARE -> "malware"
                ThreatLevel.SUSPICIOUS -> "suspicious" 
                ThreatLevel.UNKNOWN -> "unknown"
            }
            
            // Create JSON object for the app's ML analysis
            val resultJson = JSONObject().apply {
                put("packageName", result.packageName)
                put("appName", result.appName)
                put("mlStatus", mlStatus)
                put("confidence", result.confidence)
                put("predictionScore", (result.confidence * 100).toInt())
                put("analysisType", "ml_offline")
                put("sha256", result.sha256Hash ?: "")
            }
            
            jsonArray.put(resultJson)
            
            Log.i("MLUpload", "Prepared: ${result.appName} -> $mlStatus (${(result.confidence * 100).toInt()}%)")
            
        } catch (e: Exception) {
            Log.e("MLUpload", "Error processing ${result.packageName}: ${e.message}")
        }
    }
    
    // Wrap the results array in a JSON object
    val jsonPayload = JSONObject().apply {
        put("mlResults", jsonArray)
        put("analysisType", "ai_offline_scan")
        put("totalScanned", userAppResults.size)
    }
    
    // Create request body with JSON content type
    val body = RequestBody.create(
        "application/json; charset=utf-8".toMediaType(),
        jsonPayload.toString()
    )
    
    // Build HTTP POST request to ML results endpoint
    val request = Request.Builder()
        .url("http://192.168.137.1:5000/api/ml/results")
        .post(body)
        .build()
    
    // Send request asynchronously using OkHttp
    val client = OkHttpClient()
    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            Log.e("MLUpload", "❌ Failed to upload ML analysis results: ${e.message}")
        }
        
        override fun onResponse(call: Call, response: Response) {
            response.body?.string()?.let { responseString ->
                try {
                    val json = JSONObject(responseString)
                    val status = json.optString("status", "unknown")
                    val message = json.optString("message", "No message")
                    
                    if (response.isSuccessful) {
                        Log.i("MLUpload", "✅ Successfully uploaded ML results: $message")
                        
                        // Update local status map with ML results if needed
                        val resultsArray = json.optJSONArray("updatedResults")
                        resultsArray?.let { results ->
                            for (i in 0 until results.length()) {
                                val result = results.getJSONObject(i)
                                val packageName = result.getString("packageName")
                                val backendStatus = result.optString("finalStatus", "unknown")
                                
                                appStatusMap[packageName] = backendStatus
                                Log.i("MLStatus", "Updated: $packageName ➜ $backendStatus")
                            }
                        }
                    } else {
                        Log.w("MLUpload", "⚠️ Server responded with error: $message")
                    }
                    
                } catch (e: Exception) {
                    Log.e("MLUpload", "❌ Error parsing ML upload response: ${e.message}")
                }
            }
        }
    })
}


