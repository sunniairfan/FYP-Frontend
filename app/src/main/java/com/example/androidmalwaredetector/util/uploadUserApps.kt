package com.example.androidmalwaredetector.util

import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PermissionInfo
import android.util.Log
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.io.IOException

// Global status map (packageName → status)
val appStatusMap = mutableMapOf<String, String>()

// List of system package prefixes that are unreliable or should be excluded
private val UNRELIABLE_SYSTEM_PREFIXES = listOf(
    "com.android.cts",
    "com.google.android.test",
    "android.ext",
    "com.qualcomm.",
    "com.coloros.",
    "com.oplus.",
    "com.vivo.",
    "com.miui.",
    "com.huawei.",
    "com.xiaomi.",
    "com.samsung.",
    "com.sec.",
    "org.lineageos.",
    "android.test",
    "com.android.test"
)

// List of authentic system apps that should always be included
private val AUTHENTIC_SYSTEM_PACKAGES = setOf(
    "android",
    "com.android.systemui",
    "com.android.launcher3",
    "com.android.phone",
    "com.android.contacts",
    "com.android.dialer",
    "com.android.calendar",
    "com.android.email",
    "com.android.messaging",
    "com.android.gallery3d",
    "com.android.camera2",
    "com.android.deskclock",
    "com.android.documentsui",
    "com.android.packageinstaller",
    "com.android.settings",
    "com.android.providers.media",
    "com.android.providers.contacts",
    "com.android.providers.calendar",
    "com.google.android.apps.maps",
    "com.google.android.apps.mediashell",
    "com.google.android.apps.photos",
    "com.google.android.googlequicksearchbox",
    "com.google.android.gms",
    "com.google.android.webview"
)

// Function to check if a system app is authentic and should be included
private fun isAuthenticSystemApp(packageName: String): Boolean {
    // Check if it's in the authentic list
    if (AUTHENTIC_SYSTEM_PACKAGES.contains(packageName)) {
        return true
    }
    
    // Check if it's a known unreliable system app
    if (UNRELIABLE_SYSTEM_PREFIXES.any { packageName.startsWith(it) }) {
        return false
    }
    
    // For other system apps, only include if they're from official sources
    // (Google, Android, or well-known vendors)
    val officialPrefixes = listOf(
        "com.google.",
        "com.android.",
        "android."
    )
    
    return officialPrefixes.any { packageName.startsWith(it) }
}

// Function to upload metadata of both user-installed and system apps to a server
fun uploadUserApps(context: Context) {
    // Get PackageManager to query installed apps
    val pm = context.packageManager
    
    // Get both user and system apps
    val allInstalledApps = pm.getInstalledApplications(PackageManager.GET_META_DATA)
    
    // Separate arrays for user and system apps
    val userAppsArray = JSONArray()
    val systemAppsArray = JSONArray()
    
    // Process each app (user and authentic system apps)
    for (app in allInstalledApps) {
        try {
            // Determine if app is system or user app
            val isSystem = (app.flags and ApplicationInfo.FLAG_SYSTEM) != 0
            
            // Skip system apps that are not authentic
            if (isSystem && !isAuthenticSystemApp(app.packageName)) {
                continue
            }
            
            // Get app name from PackageManager
            val appName = pm.getApplicationLabel(app).toString()
            
            // Skip apps with blank names
            if (appName.isBlank()) {
                continue
            }
            
            val apkPath = app.sourceDir
            if (apkPath.isNullOrBlank()) {
                Log.w("Upload", "Skipping app ${app.packageName}: sourceDir is null or blank")
                continue
            }
            
            val apkFile = File(apkPath)
            
            // Check if APK file exists before attempting to hash
            if (!apkFile.exists()) {
                Log.w("Upload", "Skipping app ${app.packageName}: APK file not found at $apkPath")
                continue
            }
            
            // Get SHA256 hash - skip if hash cannot be computed
            val sha256 = try {
                getSha256(apkFile)
            } catch (e: Exception) {
                Log.w("Upload", "Failed to compute hash for ${app.packageName}: ${e.message}")
                // Skip apps where hash cannot be computed
                continue
            }
            
            val appSizeMb = String.format("%.2f", apkFile.length().toDouble() / (1024 * 1024)).toDouble()

            val permissionList = mutableListOf<String>()
            try {
                val packageInfo = pm.getPackageInfo(app.packageName, PackageManager.GET_PERMISSIONS)
                val requestedPermissions = packageInfo.requestedPermissions ?: emptyArray()

                for (perm in requestedPermissions) {
                    try {
                        val permInfo = pm.getPermissionInfo(perm, 0)
                        if ((permInfo.protectionLevel and PermissionInfo.PROTECTION_DANGEROUS) != 0) {
                            permissionList.add(perm)
                        }
                    } catch (_: Exception) {}
                }
            } catch (e: Exception) {
                Log.w("Upload", "Failed to get permissions for ${app.packageName}: ${e.message}")
                // Continue without permissions rather than skipping the app
            }
            
            // Create JSON object for the app with appType field
            val appJson = JSONObject().apply {
                put("appName", appName)
                put("packageName", app.packageName)
                put("sizeMB", appSizeMb)
                put("sha256", sha256)
                put("permissions", JSONArray(permissionList))
                // Add appType field: "user" or "system"
                put("appType", if (isSystem) "system" else "user")
            }

            // Add to appropriate array based on app type
            if (isSystem) {
                systemAppsArray.put(appJson)
                Log.d("Upload", "Added system app: ${app.packageName}")
            } else {
                userAppsArray.put(appJson)
                Log.d("Upload", "Added user app: ${app.packageName}")
            }

        } catch (e: Exception) {
            Log.e("Upload", "Error processing app: ${e.message}")
            e.printStackTrace()
        }
    }

    // Check if we have any apps to upload
    if (userAppsArray.length() == 0 && systemAppsArray.length() == 0) {
        Log.w("Upload", "No apps found to upload.")
        return
    }
    
    Log.i("Upload", "Uploading ${userAppsArray.length()} user apps and ${systemAppsArray.length()} system apps")
    
    // Create JSON payload with separate arrays for user and system apps
    val jsonPayload = JSONObject().apply {
        put("userApps", userAppsArray)
        put("systemApps", systemAppsArray)
    }
    
    // Create request body with JSON content type
    val body = RequestBody.create(
        "application/json; charset=utf-8".toMediaType(),
        jsonPayload.toString()
    )
    
    // Build HTTP POST request
    val request = Request.Builder()
        .url("http://192.168.137.1:5000/api/app/upload")
        .post(body)
        .build()
    
    // Send request asynchronously using OkHttp
    val client = OkHttpClient()
    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            Log.e("Upload", "❌ Failed to upload app data: ${e.message}")
        }

        override fun onResponse(call: Call, response: Response) {
            // Process server response with separated userApps and systemApps arrays
            response.body?.string()?.let { responseString ->
                try {
                    val json = JSONObject(responseString)
                    
                    Log.d("Upload", "Response from server: $responseString")
                    
                    // Check if response has userApps and systemApps arrays
                    if (!json.has("userApps") && !json.has("systemApps")) {
                        // Fallback: try old format with "results" array
                        if (json.has("results")) {
                            Log.w("Upload", "Server returned old format. Attempting to parse 'results' array.")
                            val resultsArray = json.getJSONArray("results")
                            for (i in 0 until resultsArray.length()) {
                                val result = resultsArray.getJSONObject(i)
                                val packageName = result.getString("packageName")
                                val status = result.optString("status", "unknown")
                                appStatusMap[packageName] = status
                                Log.i("AppStatus", "App: $packageName ➜ Status: $status")
                            }
                        } else {
                            Log.e("Upload", "Invalid response: Missing userApps/systemApps and results arrays")
                        }
                        return@let
                    }
                    
                    // Process userApps array
                    if (json.has("userApps")) {
                        try {
                            val userAppsArray = json.getJSONArray("userApps")
                            Log.d("Upload", "Processing ${userAppsArray.length()} user apps from response")
                            
                            for (i in 0 until userAppsArray.length()) {
                                try {
                                    val result = userAppsArray.getJSONObject(i)
                                    val packageName = result.getString("packageName")
                                    val status = result.optString("status", "unknown")
                                    val source = result.optString("source", "unknown")
                                    val appType = result.optString("appType", "user")
                                    
                                    // Extract VirusTotal hash check details if available
                                    val virusTotalInfo = if (result.has("virusTotalHashCheck")) {
                                        try {
                                            val vtCheck = result.getJSONObject("virusTotalHashCheck")
                                            val detectionRatio = vtCheck.optString("detectionRatio", "0/0")
                                            val scanTime = vtCheck.optString("scanTime", "N/A")
                                            "\n  VirusTotal: $detectionRatio | Scan: $scanTime"
                                        } catch (e: Exception) {
                                            ""
                                        }
                                    } else {
                                        ""
                                    }
                                    
                                    // Store status in map
                                    appStatusMap[packageName] = status
                                    
                                    Log.i("AppStatus", "User App: $packageName ➜ Status: $status | Source: $source$virusTotalInfo")
                                } catch (e: Exception) {
                                    Log.e("AppStatus", "Error parsing individual user app at index $i: ${e.message}")
                                }
                            }
                        } catch (e: Exception) {
                            Log.e("AppStatus", "Error parsing userApps array: ${e.message}")
                            e.printStackTrace()
                        }
                    }
                    
                    // Process systemApps array
                    if (json.has("systemApps")) {
                        try {
                            val systemAppsArray = json.getJSONArray("systemApps")
                            Log.d("Upload", "Processing ${systemAppsArray.length()} system apps from response")
                            
                            for (i in 0 until systemAppsArray.length()) {
                                try {
                                    val result = systemAppsArray.getJSONObject(i)
                                    val packageName = result.getString("packageName")
                                    val status = result.optString("status", "unknown")
                                    val source = result.optString("source", "unknown")
                                    val appType = result.optString("appType", "system")
                                    
                                    // Extract VirusTotal hash check details if available
                                    val virusTotalInfo = if (result.has("virusTotalHashCheck")) {
                                        try {
                                            val vtCheck = result.getJSONObject("virusTotalHashCheck")
                                            val detectionRatio = vtCheck.optString("detectionRatio", "0/0")
                                            val scanTime = vtCheck.optString("scanTime", "N/A")
                                            "\n  VirusTotal: $detectionRatio | Scan: $scanTime"
                                        } catch (e: Exception) {
                                            ""
                                        }
                                    } else {
                                        ""
                                    }
                                    
                                    // Store status in map
                                    appStatusMap[packageName] = status
                                    
                                    Log.i("AppStatus", "System App: $packageName ➜ Status: $status | Source: $source$virusTotalInfo")
                                } catch (e: Exception) {
                                    Log.e("AppStatus", "Error parsing individual system app at index $i: ${e.message}")
                                }
                            }
                        } catch (e: Exception) {
                            Log.e("AppStatus", "Error parsing systemApps array: ${e.message}")
                            e.printStackTrace()
                        }
                    }
                    
                    Log.i("Upload", "✅ Successfully processed app statuses from server")
                    
                } catch (e: Exception) {
                    Log.e("AppStatus", "❌ Error parsing response: ${e.message}")
                    e.printStackTrace()
                }
            }
        }
    })
}

