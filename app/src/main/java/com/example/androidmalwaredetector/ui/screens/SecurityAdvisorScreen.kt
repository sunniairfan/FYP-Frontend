package com.example.androidmalwaredetector.ui.screens

import android.bluetooth.BluetoothAdapter
import android.content.Context
import android.net.wifi.WifiManager
import android.nfc.NfcAdapter
import android.os.Build
import android.provider.Settings
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.activity.compose.BackHandler
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.example.androidmalwaredetector.ui.theme.NeonCyan
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.BufferedReader
import java.io.File
import java.io.InputStreamReader

data class SecurityCheck(
    val id: String,
    val title: String,
    val icon: ImageVector,
    val status: SecurityStatus,
    val statusText: String,
    val description: String,
    val recommendation: String?
)

enum class SecurityStatus {
    SECURE,      // Green
    WARNING,     // Yellow
    VULNERABLE,  // Red
    UNKNOWN      // Gray
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SecurityAdvisorScreen(navController: NavController) {
    val context = LocalContext.current
    var securityChecks by remember { mutableStateOf<List<SecurityCheck>>(emptyList()) }
    var isLoading by remember { mutableStateOf(true) }
    val coroutineScope = rememberCoroutineScope()
    
    // Handle back press
    androidx.activity.compose.BackHandler {
        navController.navigateUp()
    }

    // Load security checks
    LaunchedEffect(Unit) {
        coroutineScope.launch {
            securityChecks = performSecurityChecks(context)
            isLoading = false
        }
    }

    // Calculate security score
    val securityScore = remember(securityChecks) {
        if (securityChecks.isEmpty()) 0
        else {
            val secureCount = securityChecks.count { it.status == SecurityStatus.SECURE }
            ((secureCount.toFloat() / securityChecks.size) * 100).toInt()
        }
    }

    val scoreColor = when {
        securityScore >= 80 -> Color(0xFF4CAF50)
        securityScore >= 60 -> Color(0xFFFFC107)
        else -> Color(0xFFFF5252)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        "SECURITY ADVISOR",
                        fontWeight = FontWeight.Bold,
                        fontSize = 18.sp,
                        letterSpacing = 1.5.sp
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(
                            Icons.Default.ArrowBack,
                            "Back",
                            tint = NeonCyan
                        )
                    }
                },
                actions = {
                    IconButton(onClick = {
                        coroutineScope.launch {
                            isLoading = true
                            securityChecks = performSecurityChecks(context)
                            isLoading = false
                        }
                    }) {
                        Icon(
                            Icons.Default.Refresh,
                            "Refresh",
                            tint = NeonCyan
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = Color(0xFF071126),
                    titleContentColor = NeonCyan,
                    navigationIconContentColor = NeonCyan,
                    actionIconContentColor = NeonCyan
                )
            )
        },
        containerColor = Color(0xFF071126)
    ) { padding ->
        if (isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding),
                contentAlignment = Alignment.Center
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    CircularProgressIndicator(color = NeonCyan)
                    Spacer(modifier = Modifier.height(16.dp))
                    Text("Analyzing device security...", color = Color.White)
                }
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .padding(horizontal = 16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                item {
                    Spacer(modifier = Modifier.height(8.dp))
                }

                // Security Score Card
                item {
                    SecurityScoreCard(score = securityScore, color = scoreColor)
                }

                item {
                    Text(
                        "Security Checks",
                        fontSize = 18.sp,
                        fontWeight = FontWeight.Bold,
                        color = Color.White,
                        modifier = Modifier.padding(vertical = 8.dp)
                    )
                }

                // Security check items
                items(securityChecks) { check ->
                    SecurityCheckCard(check = check)
                }

                item {
                    Spacer(modifier = Modifier.height(16.dp))
                }
            }
        }
    }
}

@Composable
fun SecurityScoreCard(score: Int, color: Color) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .height(200.dp),
        shape = RoundedCornerShape(20.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color(0xFF0B1530).copy(alpha = 0.8f)
        ),
        elevation = CardDefaults.cardElevation(8.dp)
    ) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Center
            ) {
                // Circular score indicator
                Box(contentAlignment = Alignment.Center) {
                    CircularProgressIndicator(
                        progress = { score / 100f },
                        modifier = Modifier.size(140.dp),
                        color = color,
                        strokeWidth = 14.dp,
                        trackColor = Color.White.copy(alpha = 0.1f)
                    )
                    
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                            text = "$score",
                            fontSize = 42.sp,
                            fontWeight = FontWeight.Bold,
                            color = color
                        )
                        Text(
                            text = "Security Score",
                            fontSize = 13.sp,
                            color = Color.White.copy(alpha = 0.7f)
                        )
                    }
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                Text(
                    text = when {
                        score >= 80 -> "✓ Device is Secure"
                        score >= 60 -> "⚠ Needs Attention"
                        else -> "⚠ Multiple Vulnerabilities"
                    },
                    fontSize = 15.sp,
                    fontWeight = FontWeight.Medium,
                    color = color
                )
            }
        }
    }
}

@Composable
fun SecurityCheckCard(check: SecurityCheck) {
    var expanded by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier.fillMaxWidth(),
        shape = RoundedCornerShape(16.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color(0xFF0B1530).copy(alpha = 0.6f)
        ),
        onClick = { expanded = !expanded }
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Icon with status color
                Box(
                    modifier = Modifier
                        .size(48.dp)
                        .clip(CircleShape)
                        .background(
                            when (check.status) {
                                SecurityStatus.SECURE -> Color(0xFF4CAF50).copy(alpha = 0.2f)
                                SecurityStatus.WARNING -> Color(0xFFFFC107).copy(alpha = 0.2f)
                                SecurityStatus.VULNERABLE -> Color(0xFFFF5252).copy(alpha = 0.2f)
                                SecurityStatus.UNKNOWN -> Color.Gray.copy(alpha = 0.2f)
                            }
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = check.icon,
                        contentDescription = null,
                        tint = when (check.status) {
                            SecurityStatus.SECURE -> Color(0xFF4CAF50)
                            SecurityStatus.WARNING -> Color(0xFFFFC107)
                            SecurityStatus.VULNERABLE -> Color(0xFFFF5252)
                            SecurityStatus.UNKNOWN -> Color.Gray
                        },
                        modifier = Modifier.size(24.dp)
                    )
                }
                
                Spacer(modifier = Modifier.width(16.dp))
                
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = check.title,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.SemiBold,
                        color = Color.White
                    )
                    Text(
                        text = check.statusText,
                        fontSize = 14.sp,
                        color = when (check.status) {
                            SecurityStatus.SECURE -> Color(0xFF4CAF50)
                            SecurityStatus.WARNING -> Color(0xFFFFC107)
                            SecurityStatus.VULNERABLE -> Color(0xFFFF5252)
                            SecurityStatus.UNKNOWN -> Color.Gray
                        }
                    )
                }
                
                Icon(
                    imageVector = if (expanded) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,
                    contentDescription = null,
                    tint = Color.White.copy(alpha = 0.6f)
                )
            }
            
            // Expanded content
            if (expanded) {
                Spacer(modifier = Modifier.height(12.dp))
                Divider(color = Color.White.copy(alpha = 0.1f))
                Spacer(modifier = Modifier.height(12.dp))
                
                Text(
                    text = check.description,
                    fontSize = 13.sp,
                    color = Color.White.copy(alpha = 0.8f),
                    lineHeight = 18.sp
                )
                
                check.recommendation?.let { recommendation ->
                    Spacer(modifier = Modifier.height(8.dp))
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(
                            containerColor = NeonCyan.copy(alpha = 0.1f)
                        ),
                        shape = RoundedCornerShape(8.dp)
                    ) {
                        Row(
                            modifier = Modifier.padding(12.dp),
                            verticalAlignment = Alignment.Top
                        ) {
                            Icon(
                                imageVector = Icons.Default.Info,
                                contentDescription = null,
                                tint = NeonCyan,
                                modifier = Modifier.size(20.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = recommendation,
                                fontSize = 12.sp,
                                color = Color.White.copy(alpha = 0.9f),
                                lineHeight = 16.sp
                            )
                        }
                    }
                }
            }
        }
    }
}

suspend fun performSecurityChecks(context: Context): List<SecurityCheck> = withContext(Dispatchers.IO) {
    val checks = mutableListOf<SecurityCheck>()
    
    // 1. Root Status
    val isRooted = checkRootStatus()
    checks.add(
        SecurityCheck(
            id = "root_status",
            title = "Root Status",
            icon = Icons.Default.Lock,
            status = if (isRooted) SecurityStatus.VULNERABLE else SecurityStatus.SECURE,
            statusText = if (isRooted) "Rooted" else "Not Rooted",
            description = "A rooted device has elevated privileges that can be exploited by malicious apps.",
            recommendation = if (isRooted) "Rooting your device compromises security. Consider unrooting for better protection." else null
        )
    )
    
    // 2. USB Debugging
    val usbDebugging = try {
        Settings.Global.getInt(context.contentResolver, Settings.Global.ADB_ENABLED, 0) == 1
    } catch (e: Exception) {
        false
    }
    checks.add(
        SecurityCheck(
            id = "usb_debugging",
            title = "USB Debugging Status",
            icon = Icons.Default.Settings,
            status = if (usbDebugging) SecurityStatus.WARNING else SecurityStatus.SECURE,
            statusText = if (usbDebugging) "Enabled" else "Disabled",
            description = "USB debugging allows computers to access your device, which can be a security risk.",
            recommendation = if (usbDebugging) "Disable USB debugging unless actively developing apps." else null
        )
    )
    
    // 3. Developer Options
    val developerMode = try {
        Settings.Global.getInt(context.contentResolver, Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 0) == 1
    } catch (e: Exception) {
        false
    }
    checks.add(
        SecurityCheck(
            id = "developer_mode",
            title = "Developer Options",
            icon = Icons.Default.Build,
            status = if (developerMode) SecurityStatus.WARNING else SecurityStatus.SECURE,
            statusText = if (developerMode) "Enabled" else "Disabled",
            description = "Developer options provide advanced settings that can weaken security if misused.",
            recommendation = if (developerMode) "Disable developer options if not needed for development." else null
        )
    )
    
    // 4. Unknown Sources
    val unknownSources = try {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            context.packageManager.canRequestPackageInstalls()
        } else {
            @Suppress("DEPRECATION")
            Settings.Secure.getInt(context.contentResolver, Settings.Secure.INSTALL_NON_MARKET_APPS, 0) == 1
        }
    } catch (e: Exception) {
        false
    }
    checks.add(
        SecurityCheck(
            id = "unknown_sources",
            title = "Unknown Source Installation",
            icon = Icons.Default.Warning,
            status = if (unknownSources) SecurityStatus.VULNERABLE else SecurityStatus.SECURE,
            statusText = if (unknownSources) "Allowed" else "Blocked",
            description = "Allowing installation from unknown sources can lead to malware infections.",
            recommendation = if (unknownSources) "Disable unknown sources to prevent installing malicious apps." else null
        )
    )
    
    // 5. Screen Lock
    val hasLockScreen = try {
        val keyguardManager = context.getSystemService(Context.KEYGUARD_SERVICE) as? android.app.KeyguardManager
        keyguardManager?.isKeyguardSecure == true
    } catch (e: Exception) {
        false
    }
    checks.add(
        SecurityCheck(
            id = "lock_screen",
            title = "Lock Screen Status",
            icon = Icons.Default.Lock,
            status = if (hasLockScreen) SecurityStatus.SECURE else SecurityStatus.VULNERABLE,
            statusText = if (hasLockScreen) "Enabled" else "Disabled",
            description = "A lock screen prevents unauthorized access to your device.",
            recommendation = if (!hasLockScreen) "Enable a lock screen with PIN, pattern, or biometric authentication." else null
        )
    )
    
    // 6. Device Encryption
    val isEncrypted = try {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val devicePolicyManager = context.getSystemService(Context.DEVICE_POLICY_SERVICE) as? android.app.admin.DevicePolicyManager
            devicePolicyManager?.storageEncryptionStatus == android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE
        } else {
            true // Assumed encrypted on newer devices
        }
    } catch (e: Exception) {
        true // Assume encrypted if can't check
    }
    checks.add(
        SecurityCheck(
            id = "encryption",
            title = "Device Encryption",
            icon = Icons.Default.Lock,
            status = if (isEncrypted) SecurityStatus.SECURE else SecurityStatus.VULNERABLE,
            statusText = if (isEncrypted) "Enabled" else "Disabled",
            description = "Encryption protects your data from unauthorized access if device is lost or stolen.",
            recommendation = if (!isEncrypted) "Enable device encryption in security settings." else null
        )
    )
    
    // 7. Bluetooth Status
    val bluetoothEnabled = try {
        val bluetoothAdapter = BluetoothAdapter.getDefaultAdapter()
        bluetoothAdapter?.isEnabled == true
    } catch (e: Exception) {
        false
    }
    checks.add(
        SecurityCheck(
            id = "bluetooth",
            title = "Bluetooth",
            icon = Icons.Default.Phone,
            status = if (bluetoothEnabled) SecurityStatus.WARNING else SecurityStatus.SECURE,
            statusText = if (bluetoothEnabled) "Enabled" else "Disabled",
            description = "Bluetooth can be used to track your device or perform unauthorized connections.",
            recommendation = if (bluetoothEnabled) "Disable Bluetooth when not in use to prevent unauthorized access." else null
        )
    )
    
    // 8. NFC Status
    val nfcEnabled = try {
        val nfcAdapter = NfcAdapter.getDefaultAdapter(context)
        nfcAdapter?.isEnabled == true
    } catch (e: Exception) {
        false
    }
    checks.add(
        SecurityCheck(
            id = "nfc",
            title = "NFC",
            icon = Icons.Default.Star,
            status = if (nfcEnabled) SecurityStatus.WARNING else SecurityStatus.SECURE,
            statusText = if (nfcEnabled) "Enabled" else "Disabled",
            description = "NFC can be exploited for unauthorized data transfer or payment fraud.",
            recommendation = if (nfcEnabled) "Disable NFC when not needed for payments or data transfer." else null
        )
    )
    
    // 9. Wi-Fi Status
    val wifiEnabled = try {
        val wifiManager = context.applicationContext.getSystemService(Context.WIFI_SERVICE) as? WifiManager
        wifiManager?.isWifiEnabled == true
    } catch (e: Exception) {
        false
    }
    checks.add(
        SecurityCheck(
            id = "wifi",
            title = "Wi-Fi",
            icon = Icons.Default.Settings,
            status = if (wifiEnabled) SecurityStatus.WARNING else SecurityStatus.SECURE,
            statusText = if (wifiEnabled) "Enabled" else "Disabled",
            description = "Open Wi-Fi networks can expose your data to attackers.",
            recommendation = if (wifiEnabled) "Use secure Wi-Fi networks and consider using a VPN on public networks." else null
        )
    )
    
    // 10. Google Play Protect
    val playProtectEnabled = try {
        Settings.Global.getInt(context.contentResolver, "package_verifier_enable", 0) == 1
    } catch (e: Exception) {
        true // Assume enabled if can't check
    }
    checks.add(
        SecurityCheck(
            id = "play_protect",
            title = "Google Play Protect",
            icon = Icons.Default.Check,
            status = if (playProtectEnabled) SecurityStatus.SECURE else SecurityStatus.VULNERABLE,
            statusText = if (playProtectEnabled) "Enabled" else "Disabled",
            description = "Google Play Protect scans apps for harmful behavior.",
            recommendation = if (!playProtectEnabled) "Enable Google Play Protect in Play Store settings." else null
        )
    )
    
    // 11. SEAndroid Status
    val seLinuxStatus = getSELinuxStatus()
    checks.add(
        SecurityCheck(
            id = "seandroid",
            title = "SEAndroid Enforcement Mode",
            icon = Icons.Default.Settings,
            status = when (seLinuxStatus) {
                "Enforcing" -> SecurityStatus.SECURE
                "Permissive" -> SecurityStatus.WARNING
                else -> SecurityStatus.VULNERABLE
            },
            statusText = seLinuxStatus,
            description = "SEAndroid enforces kernel-level security policies to prevent unauthorized access.",
            recommendation = if (seLinuxStatus != "Enforcing") "SEAndroid should be in Enforcing mode. This may indicate a compromised device." else null
        )
    )
    
    // 12. Mobile Hotspot
    val hotspotEnabled = try {
        val wifiManager = context.applicationContext.getSystemService(Context.WIFI_SERVICE) as? WifiManager
        val method = wifiManager?.javaClass?.getDeclaredMethod("isWifiApEnabled")
        method?.isAccessible = true
        method?.invoke(wifiManager) as? Boolean ?: false
    } catch (e: Exception) {
        false
    }
    checks.add(
        SecurityCheck(
            id = "hotspot",
            title = "Mobile Hotspot",
            icon = Icons.Default.Settings,
            status = if (hotspotEnabled) SecurityStatus.WARNING else SecurityStatus.SECURE,
            statusText = if (hotspotEnabled) "Enabled" else "Disabled",
            description = "Mobile hotspot shares your internet connection and can expose your device to unauthorized access.",
            recommendation = if (hotspotEnabled) "Disable mobile hotspot when not in use to prevent unauthorized connections." else null
        )
    )
    
    // 13. VPN Status
    val vpnEnabled = try {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as? android.net.ConnectivityManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val network = connectivityManager?.activeNetwork
            val capabilities = connectivityManager?.getNetworkCapabilities(network)
            capabilities?.hasTransport(android.net.NetworkCapabilities.TRANSPORT_VPN) == true
        } else {
            false
        }
    } catch (e: Exception) {
        false
    }
    checks.add(
        SecurityCheck(
            id = "vpn",
            title = "VPN Connection",
            icon = Icons.Default.Settings,
            status = if (vpnEnabled) SecurityStatus.SECURE else SecurityStatus.WARNING,
            statusText = if (vpnEnabled) "Connected" else "Not Connected",
            description = "VPN encrypts your internet traffic and protects your privacy on public networks.",
            recommendation = if (!vpnEnabled) "Consider using a VPN for secure browsing, especially on public Wi-Fi." else null
        )
    )
    
    // 14. Wi-Fi Security
    val wifiSecure = try {
        val wifiManager = context.applicationContext.getSystemService(Context.WIFI_SERVICE) as? WifiManager
        val wifiInfo = wifiManager?.connectionInfo
        if (wifiInfo != null && wifiManager.isWifiEnabled) {
            val ssid = wifiInfo.ssid
            if (ssid != null && ssid != "<unknown ssid>") {
                true // Assume secure if connected
            } else {
                true
            }
        } else {
            true // Not connected, so secure
        }
    } catch (e: Exception) {
        true
    }
    checks.add(
        SecurityCheck(
            id = "wifi_security",
            title = "Wi-Fi Security Features",
            icon = Icons.Default.Settings,
            status = if (wifiSecure) SecurityStatus.SECURE else SecurityStatus.VULNERABLE,
            statusText = if (wifiSecure) "Secure" else "Insecure",
            description = "Open or unencrypted Wi-Fi networks can expose your data to attackers.",
            recommendation = if (!wifiSecure) "Disconnect from open networks and use secure WPA2/WPA3 networks." else null
        )
    )
    
    checks
}

fun checkRootStatus(): Boolean {
    // Check for common root indicators
    val rootIndicators = listOf(
        "/system/app/Superuser.apk",
        "/sbin/su",
        "/system/bin/su",
        "/system/xbin/su",
        "/data/local/xbin/su",
        "/data/local/bin/su",
        "/system/sd/xbin/su",
        "/system/bin/failsafe/su",
        "/data/local/su"
    )
    
    for (path in rootIndicators) {
        if (File(path).exists()) {
            return true
        }
    }
    
    // Check for su binary
    return try {
        Runtime.getRuntime().exec("su")
        true
    } catch (e: Exception) {
        false
    }
}

fun getSELinuxStatus(): String {
    return try {
        val process = Runtime.getRuntime().exec("getenforce")
        val reader = BufferedReader(InputStreamReader(process.inputStream))
        val status = reader.readLine() ?: "Unknown"
        reader.close()
        status.trim()
    } catch (e: Exception) {
        "Unknown"
    }
}
